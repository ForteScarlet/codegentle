@file:JvmName("CodeValues")

package love.forte.codegentle.java

import love.forte.codegentle.common.code.CodeArgumentPart
import love.forte.codegentle.common.code.CodePart
import love.forte.codegentle.common.code.CodeSimplePart
import love.forte.codegentle.common.code.CodeValue
import love.forte.codegentle.common.naming.ClassName
import love.forte.codegentle.common.naming.canonicalName
import love.forte.codegentle.common.writer.InternalWriterApi
import love.forte.codegentle.java.naming.emitTo
import love.forte.codegentle.java.writer.JavaCodeWriter
import kotlin.jvm.JvmName

//
// /**
//  * ```kotlin
//  * CodeValue(format = "%V %V = %V;") {
//  *     value(CodePart.type(ClassName("java.lang", "String")))
//  *     value(CodePart.literal("value"))
//  *     value(CodePart.string("Hello, World"))
//  * }
//  * ```
//  * Will get:
//  *
//  * ```kotlin
//  * java.lang.String value = "Hello, World";
//  * ```
//  *
//  * @author ForteScarlet
//  */
// @Deprecated("Use CodeValue instead", replaceWith = ReplaceWith("CodeValue",  "love.forte.codegentle.common.code.CodeValue"))
// public interface JavaCodeValue : CodeValue, JavaCodeEmitter {
//     override val parts: List<CodePart>
//
//     override fun emit(codeWriter: JavaCodeWriter) {
//         emit(codeWriter, ensureTrailingNewline = false)
//     }
//
//     public fun emit(codeWriter: JavaCodeWriter, ensureTrailingNewline: Boolean) {
//         emitTo(codeWriter, ensureTrailingNewline)
//     }
//
//     public companion object {
//         internal val EMPTY = JavaJavaCodeValueImpl(emptyList())
//
//         @JvmStatic
//         public fun builder(format: String): JavaCodeValueSingleFormatBuilder = JavaCodeValueSingleFormatBuilder(format)
//
//         @JvmStatic
//         public fun builder(): JavaCodeValueBuilder = JavaCodeValueBuilder()
//     }
// }
//
// public operator fun JavaCodeValue.plus(codeValue: JavaCodeValue): JavaCodeValue {
//     return JavaCodeValue(parts + codeValue.parts)
// }
//
// public typealias CodeValueSingleFormatBuilderDsl = JavaCodeValueSingleFormatBuilder.() -> Unit
// public typealias CodeValueBuilderDsl = JavaCodeValueBuilder.() -> Unit
//
// // TODO auto-generated by KSP
//
// public fun JavaCodeValueSingleFormatBuilder.skip(): JavaCodeValueSingleFormatBuilder = value(CodePart.skip())
// public fun JavaCodeValueSingleFormatBuilder.literal(value: Any?): JavaCodeValueSingleFormatBuilder =
//     value(CodePart.literal(value))
//
// public fun JavaCodeValueSingleFormatBuilder.name(name: String?): JavaCodeValueSingleFormatBuilder =
//     value(CodePart.name(name = name))
//
// public fun JavaCodeValueSingleFormatBuilder.name(nameValue: Any): JavaCodeValueSingleFormatBuilder =
//     value(CodePart.name(nameValue = nameValue))
//
// public fun JavaCodeValueSingleFormatBuilder.string(value: String?): JavaCodeValueSingleFormatBuilder =
//     value(CodePart.string(value))
//
// public fun JavaCodeValueSingleFormatBuilder.type(type: TypeName): JavaCodeValueSingleFormatBuilder =
//     // TODO Type -> Ref?
//     value(CodePart.type(type))
//
// public fun JavaCodeValueSingleFormatBuilder.type(type: TypeRef<*>): JavaCodeValueSingleFormatBuilder =
//     // TODO Type -> Ref?
//     value(CodePart.type(type))
//
// // TODO JVM
//
// public fun JavaCodeValueSingleFormatBuilder.indent(levels: Int = 1): JavaCodeValueSingleFormatBuilder =
//     value(CodePart.indent(levels))
//
// public fun JavaCodeValueSingleFormatBuilder.unindent(levels: Int = 1): JavaCodeValueSingleFormatBuilder =
//     value(CodePart.unindent(levels))
//
// public fun JavaCodeValueSingleFormatBuilder.statementBegin(): JavaCodeValueSingleFormatBuilder =
//     value(CodePart.statementBegin())
//
// public fun JavaCodeValueSingleFormatBuilder.statementEnd(): JavaCodeValueSingleFormatBuilder =
//     value(CodePart.statementEnd())
//
// public fun JavaCodeValueSingleFormatBuilder.wrappingSpace(): JavaCodeValueSingleFormatBuilder =
//     value(CodePart.wrappingSpace())
//
// public fun JavaCodeValueSingleFormatBuilder.zeroWidthSpace(): JavaCodeValueSingleFormatBuilder =
//     value(CodePart.zeroWidthSpace())
//
// public fun JavaCodeValueSingleFormatBuilder.otherCodeValue(value: JavaCodeValue): JavaCodeValueSingleFormatBuilder =
//     value(CodePart.otherCodeValue(value))
//
// internal fun JavaCodeValue(parts: List<CodePart>): JavaCodeValue {
//     return JavaJavaCodeValueImpl(parts)
// }
//
// internal fun JavaCodeValue(part: CodePart): JavaCodeValue {
//     return JavaJavaCodeValueImpl(listOf(part))
// }
//
// public inline fun JavaCodeValue(format: String, block: CodeValueSingleFormatBuilderDsl = {}): JavaCodeValue {
//     return JavaCodeValue.builder(format).also(block).build()
// }
//
// @JvmName("of")
// public fun JavaCodeValue(format: String, argumentPart: CodeArgumentPart): JavaCodeValue {
//     return JavaCodeValue(format) {
//         value(argumentPart)
//     }
// }
//
// @JvmName("of")
// public fun JavaCodeValue(format: String, vararg argumentParts: CodeArgumentPart): JavaCodeValue {
//     return JavaCodeValue(format) {
//         values(*argumentParts)
//     }
// }
//
// @JvmName("of")
// public fun JavaCodeValue(format: String, argumentParts: Iterable<CodeArgumentPart>): JavaCodeValue {
//     return JavaCodeValue(format) {
//         values(argumentParts)
//     }
// }
//
// public inline fun JavaCodeValue(block: CodeValueBuilderDsl): JavaCodeValue {
//     return JavaCodeValue.builder().also(block).build()
// }
//
// // Builders
//
// public inline fun JavaCodeValueBuilder.addStatement(
//     format: String,
//     block: CodeValueSingleFormatBuilderDsl = {}
// ): JavaCodeValueBuilder = apply {
//     addStatement(JavaCodeValue(format, block))
// }
//
//
// public inline fun JavaCodeValueBuilder.beginControlFlow(
//     controlFlow: String,
//     block: CodeValueSingleFormatBuilderDsl = {}
// ): JavaCodeValueBuilder =
//     apply {
//         add("$controlFlow {\n") { block() }
//         indent()
//     }
//
// public inline fun JavaCodeValueBuilder.nextControlFlow(
//     controlFlow: String,
//     block: CodeValueSingleFormatBuilderDsl = {}
// ): JavaCodeValueBuilder =
//     apply {
//         unindent()
//         add("} $controlFlow {\n") { block() }
//         indent()
//     }
//
// /**
//  * @param controlFlow the optional control flow construct and its code, such as
//  * `"while(foo == 20)"`. Only used for `"do/while"` control flows.
//  */
// public inline fun JavaCodeValueBuilder.endControlFlow(
//     controlFlow: String,
//     block: CodeValueSingleFormatBuilderDsl = {}
// ): JavaCodeValueBuilder =
//     apply {
//         unindent()
//         add("} $controlFlow;\n") { block() }
//     }
//
// /**
//  * ```Kotlin
//  * builder {
//  *  "%V, %V" {
//  *    value(...) // for 1st `%V`
//  *    value(...) // for 2nd `%V`
//  *  }
//  *  // Same as
//  *  add("%V, %V") {
//  *    value(...) // for 1st `%V`
//  *    value(...) // for 2nd `%V`
//  *  }
//  * }
//  * ```
//  */
// public class JavaCodeValueBuilder internal constructor() : BuilderDsl {
//     private val parts = mutableListOf<CodePart>()
//
//     @PublishedApi
//     internal fun addParts(parts: List<CodePart>): JavaCodeValueBuilder = apply {
//         this.parts.addAll(parts)
//     }
//
//     public fun add(codeValue: JavaCodeValue): JavaCodeValueBuilder = apply {
//         parts.addAll(codeValue.parts)
//     }
//
//     public fun add(format: String): JavaCodeValueBuilder = apply {
//         parts.add(CodePart.simple(format))
//     }
//
//     public fun add(format: String, vararg argumentParts: CodeArgumentPart): JavaCodeValueBuilder = apply {
//         addParts(JavaCodeValue.Companion.builder(format).values(*argumentParts).parts())
//     }
//
//     public inline fun add(format: String, block: JavaCodeValueSingleFormatBuilder.() -> Unit): JavaCodeValueBuilder =
//         apply {
//             addParts(JavaCodeValue.Companion.builder(format).also(block).parts())
//         }
//
//     public inline operator fun String.invoke(block: JavaCodeValueSingleFormatBuilder.() -> Unit): JavaCodeValueBuilder =
//         add(this, block)
//
//     public fun addStatement(format: String, vararg argumentParts: CodeArgumentPart): JavaCodeValueBuilder = apply {
//         parts.add(CodePart.statementBegin())
//         add(JavaCodeValue(format, *argumentParts))
//         add(";\n")
//         parts.add(CodePart.statementEnd())
//     }
//
//     public fun addStatement(codeValue: JavaCodeValue): JavaCodeValueBuilder = apply {
//         parts.add(CodePart.statementBegin())
//         add(codeValue)
//         add(";\n")
//         parts.add(CodePart.statementEnd())
//     }
//
//     public fun beginControlFlow(controlFlow: String, vararg argumentParts: CodeArgumentPart): JavaCodeValueBuilder =
//         apply {
//             add("$controlFlow {\n", *argumentParts)
//             indent()
//         }
//
//     public fun nextControlFlow(controlFlow: String, vararg argumentParts: CodeArgumentPart): JavaCodeValueBuilder =
//         apply {
//             unindent()
//             add("} $controlFlow {\n", *argumentParts)
//             indent()
//         }
//
//     public fun endControlFlow(): JavaCodeValueBuilder = apply {
//         unindent()
//         add("}\n")
//     }
//
//     /**
//      * @param controlFlow the optional control flow construct and its code, such as
//      * `"while(foo == 20)"`. Only used for `"do/while"` control flows.
//      */
//     public fun endControlFlow(controlFlow: String, vararg argumentParts: CodeArgumentPart): JavaCodeValueBuilder =
//         apply {
//             unindent()
//             add("} $controlFlow;\n", *argumentParts)
//         }
//
//     public fun indent(): JavaCodeValueBuilder = apply {
//         parts.add(CodePart.indent())
//     }
//
//     public fun unindent(): JavaCodeValueBuilder = apply {
//         parts.add(CodePart.unindent())
//     }
//
//     public fun clear(): JavaCodeValueBuilder = apply {
//         parts.clear()
//     }
//
//     public fun build(): JavaCodeValue = JavaJavaCodeValueImpl(parts)
// }
//
// /**
//  * The Builder for [JavaCodeValue] with single [format] target.
//  *
//  * ```Kotlin
//  * builder("%V %V = %V;") {
//  *   value(...) // For 1st `%V`
//  *   value(...) // For 2nd `%V`
//  *   value(...) // For 3rd `%V`
//  * }.build()
//  * ```
//  *
//  */
// public class JavaCodeValueSingleFormatBuilder internal constructor(public val format: String) : BuilderDsl {
//     private val arguments = mutableListOf<CodeArgumentPart>()
//
//     /**
//      * Add a [CodeArgumentPart] for next argument placeholder.
//      */
//     public fun value(argument: CodeArgumentPart): JavaCodeValueSingleFormatBuilder = apply {
//         arguments.add(argument)
//     }
//
//     /**
//      * Add some [CodeArgumentPart]s for next argument placeholder.
//      */
//     public fun values(vararg arguments: CodeArgumentPart): JavaCodeValueSingleFormatBuilder = apply {
//         this.arguments.addAll(arguments)
//     }
//
//     /**
//      * Add some [CodeArgumentPart]s for next argument placeholder.
//      */
//     public fun values(arguments: Iterable<CodeArgumentPart>): JavaCodeValueSingleFormatBuilder = apply {
//         this.arguments.addAll(arguments)
//     }
//
//     @PublishedApi
//     internal fun parts(): List<CodePart> {
//         if (arguments.isEmpty()) {
//             return listOf(CodePart.simple(format))
//         }
//
//         val argumentsStack = ArrayDeque(arguments)
//         val parts = mutableListOf<CodePart>()
//
//         var last = false
//
//         var i = 0
//         for (simplePart in format.splitToSequence(CodePart.PLACEHOLDER)) {
//             if (simplePart.isNotEmpty()) {
//                 parts.add(CodePart.simple(simplePart))
//             }
//             // remove stack first
//             val nextArg = argumentsStack.removeFirstOrNull()
//
//             if (nextArg == null) {
//                 check(!last) { "Miss argument in index $i" }
//                 last = true
//             } else {
//                 parts.add(nextArg)
//             }
//
//             i++
//         }
//
//         check(argumentsStack.isEmpty()) { "${argumentsStack.size} redundant argument(s): $argumentsStack" }
//
//         return parts
//     }
//
//     public fun build(): JavaCodeValue = JavaJavaCodeValueImpl(parts())
// }


@OptIn(InternalWriterApi::class)
internal fun CodeValue.emitTo(codeWriter: JavaCodeWriter, ensureTrailingNewline: Boolean = false) {
    var deferredTypeName: ClassName? = null
    val iterator = parts.listIterator()

    while (iterator.hasNext()) {
        when (val part = iterator.next()) {
            is CodeSimplePart -> {
                val value = part.value
                // handle deferred type
                if (deferredTypeName != null) {
                    if (value.startsWith(".")) {
                        if (codeWriter.emitStaticImportMember(deferredTypeName.canonicalName, value)) {
                            // okay, static import hit and all was emitted, so clean-up and jump to next part
                            deferredTypeName = null
                            continue
                        }
                    }
                    deferredTypeName.emitTo(codeWriter)
                    deferredTypeName = null
                }
                codeWriter.emitAndIndent(value)
            }

            is CodeArgumentPart.Skip -> {
                codeWriter.emit(CodePart.PLACEHOLDER)
            }

            is CodeArgumentPart.Literal -> {
                codeWriter.emitLiteral(part.value)
            }

            is CodeArgumentPart.Name -> {
                codeWriter.emitLiteral(part.name)
            }

            is CodeArgumentPart.Str -> {
                codeWriter.emitAndIndent(
                    part.value?.literalWithDoubleQuotes(codeWriter.indentValue)
                        ?: "null"
                )
            }

            is CodeArgumentPart.Type -> {
                val typeName = part.type
                // TODO 下面这逻辑干啥的？
                if (typeName is ClassName && iterator.hasNext()) {
                    val next = parts[iterator.nextIndex()]
                    // !next.start('$')
                    if (next !is CodeArgumentPart) {
                        val candidate: ClassName = typeName
                        if (codeWriter.staticImportClassNames.contains(candidate)) {
                            check(deferredTypeName == null) { "pending type for static import?!" }
                            deferredTypeName = candidate
                            continue
                        }
                    }
                }

                codeWriter.emit(typeName)
            }

            is CodeArgumentPart.TypeRef -> {
                val typeRef = part.type
                val typeName = typeRef.typeName
                // TODO 下面这逻辑干啥的？
                if (typeName is ClassName && iterator.hasNext()) {
                    val next = parts[iterator.nextIndex()]
                    // !next.start('$')
                    if (next !is CodeArgumentPart) {
                        val candidate: ClassName = typeName
                        if (codeWriter.staticImportClassNames.contains(candidate)) {
                            check(deferredTypeName == null) { "pending type for static import?!" }
                            deferredTypeName = candidate
                            continue
                        }
                    }
                }

                codeWriter.emit(typeRef)
            }


            is CodeArgumentPart.Indent -> {
                codeWriter.indent(part.levels)
            }

            is CodeArgumentPart.Unindent -> {
                codeWriter.unindent(part.levels)
            }

            is CodeArgumentPart.StatementBegin -> {
                check(codeWriter.statementLine == -1) {
                    "statement enter $[ followed by statement enter $["
                }
                codeWriter.statementLine = 0
            }

            is CodeArgumentPart.StatementEnd -> {
                check(codeWriter.statementLine != -1) {
                    "statement exit $] has no matching statement enter $["
                }
                if (codeWriter.statementLine > 0) {
                    codeWriter.unindent(2) // End a multi-line statement. Decrease the indentation level.
                }
                codeWriter.statementLine = -1
            }

            is CodeArgumentPart.WrappingSpace -> {
                codeWriter.out.wrappingSpace(codeWriter.indentLevel + 2)
            }

            is CodeArgumentPart.ZeroWidthSpace -> {
                codeWriter.out.zeroWidthSpace(codeWriter.indentLevel + 2)
            }

            is CodeArgumentPart.OtherCodeValue -> {
                codeWriter.emit(part.value)
            }

        }
    }

    if (ensureTrailingNewline && codeWriter.out.lastChar != '\n') {
        codeWriter.emit("\n")
    }
}
