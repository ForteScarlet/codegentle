package love.forte.codegentle.internal.processor.codevalueextension

import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.*
import java.time.ZoneId
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter
import java.time.format.FormatStyle
import java.util.*

/**
 *
 * @author ForteScarlet
 */
internal class CodeValueExtensionsProcessor(private val environment: SymbolProcessorEnvironment) : SymbolProcessor {
    private val logger = environment.logger
    private val codePartFactoryAnnotationName = "love.forte.codegentle.common.code.CodePartFactory"
    private val codePartClassName = "love.forte.codegentle.common.code.CodePart"

    private var codePartFile: KSFile? = null
    private val collectedFactoryFunctions = mutableListOf<KSFunctionDeclaration>()

    override fun process(resolver: Resolver): List<KSAnnotated> {
        // Find the CodePart class
        val codePartClass = resolver.getClassDeclarationByName(resolver.getKSNameFromString(codePartClassName))
        if (codePartClass == null) {
            logger.error("Could not find CodePart class")
            return emptyList()
        }

        codePartFile = codePartClass.containingFile

        // Find the companion object of CodePart
        val companionObject = codePartClass.declarations.firstOrNull {
            it is KSClassDeclaration && it.simpleName.asString() == "Companion"
        } as? KSClassDeclaration

        if (companionObject == null) {
            logger.error("Could not find companion object of CodePart")
            return emptyList()
        }

        // Find all functions in the companion object that are marked with @CodePartFactory
        val factoryFunctions = companionObject.declarations
            .filterIsInstance<KSFunctionDeclaration>()
            .filter { function ->
                function.annotations.any { annotation ->
                    annotation.annotationType.resolve().declaration.qualifiedName?.asString() == codePartFactoryAnnotationName
                }
            }
            .toList()

        logger.info("Found ${factoryFunctions.size} factory functions in CodePart companion object")

        collectedFactoryFunctions.addAll(factoryFunctions)

        return emptyList()
    }

    override fun finish() {
        if (collectedFactoryFunctions.isEmpty()) {
            logger.warn("No factory functions found, skipping code generation")
            return
        }

        generateExtensionFunctions()
    }

    private fun nowTime(): String {
        return DateTimeFormatter
            .ofLocalizedDateTime(FormatStyle.FULL)
            .withLocale(Locale.ROOT)
            .format(ZonedDateTime.now(ZoneId.of("UTC")))
    }

    private fun generateExtensionFunctions() {
        // Set aggregating to true as required
        val dependencies = Dependencies(true, codePartFile!!)

        val outputFile = environment.codeGenerator.createNewFile(
            dependencies,
            "love.forte.codegentle.common.code",
            "CodeValueExtensions"
        )

        outputFile.bufferedWriter().use { writer ->
            writer.write("// Generated by CodeValueExtensionsProcessor at ${nowTime()}\n")
            writer.write("package love.forte.codegentle.common.code\n\n")

            for (function in collectedFactoryFunctions) {
                val functionName = function.simpleName.asString()
                val parameters = function.parameters

                // Handle type parameters of the function
                val typeParameters = function.typeParameters
                val typeParametersString = if (typeParameters.isNotEmpty()) {
                    typeParameters.joinToString(", ", "<", ">") { typeParam ->
                        buildTypeParameterString(typeParam)
                    }
                } else {
                    ""
                }

                // Check if any parameters have default values
                val hasDefaultParams = parameters.any { it.hasDefault }

                // Generate the function with all parameters
                val allParameterList = parameters.joinToString(", ") { param ->
                    buildParameterString(param)
                }

                val allArgumentList = parameters.joinToString(", ") { param ->
                    val paramName = param.name?.asString() ?: "_"
                    paramName
                }

                writer.write("/**\n")
                writer.write(" * Extension function for [CodeValueSingleFormatBuilder] that calls [CodePart.$functionName].\n")
                writer.write(" */\n")
                writer.write("public fun$typeParametersString CodeValueSingleFormatBuilder.emit${functionName.capitalize()}($allParameterList): CodeValueSingleFormatBuilder =\n")
                writer.write("    addValue(CodePart.$functionName($allArgumentList))\n\n")

                // If there are parameters with default values, generate a second function without those parameters
                if (hasDefaultParams) {
                    // Filter out parameters with default values
                    val requiredParams = parameters.filterNot { it.hasDefault }

                    val requiredParameterList = requiredParams.joinToString(", ") { param ->
                        buildParameterString(param)
                    }

                    val requiredArgumentList = requiredParams.joinToString(", ") { param ->
                        val paramName = param.name?.asString() ?: "_"
                        paramName
                    }

                    writer.write("/**\n")
                    writer.write(" * Extension function for [CodeValueSingleFormatBuilder] that calls [CodePart.$functionName] with default parameter values.\n")
                    writer.write(" */\n")
                    writer.write("public fun$typeParametersString CodeValueSingleFormatBuilder.emit${functionName.capitalize()}($requiredParameterList): CodeValueSingleFormatBuilder =\n")
                    writer.write("    addValue(CodePart.$functionName($requiredArgumentList))\n\n")
                }
            }
        }

        logger.info("Generated extension functions for ${collectedFactoryFunctions.size} factory functions")
    }

    private fun buildTypeParameterString(typeParam: KSTypeParameter): String {
        val name = typeParam.name.asString()
        val bounds = typeParam.bounds.toList()

        val boundsString = if (bounds.isNotEmpty()) {
            bounds.joinToString(", ", " : ") { bound ->
                bound.resolve().declaration.qualifiedName?.asString() ?: bound.toString()
            }
        } else {
            ""
        }

        val variance = when (typeParam.variance) {
            Variance.COVARIANT -> "out "
            Variance.CONTRAVARIANT -> "in "
            else -> ""
        }

        return "$variance$name$boundsString"
    }

    private fun buildParameterString(param: KSValueParameter): String {
        val paramName = param.name?.asString() ?: "_"
        val paramType = param.type.resolve()

        // Build the full type string including generic arguments
        val typeString = buildTypeString(paramType)

        // For parameters with default values, we need to handle them specially
        // In KSP, we can't directly access the default value text
        // Instead of using a placeholder, we'll just omit the default value
        // The function will still work correctly because the default value is handled by the original function

        return "$paramName: $typeString"
    }

    private fun buildTypeString(type: KSType): String {
        val declaration = type.declaration
        val baseName = declaration.qualifiedName?.asString() ?: declaration.toString()

        // Add nullability marker
        val nullMark = if (type.isMarkedNullable) "?" else ""

        // If there are no type arguments, just return the base name with nullability
        if (type.arguments.isEmpty()) {
            return "$baseName$nullMark"
        }

        // Build the type arguments string
        val typeArgs = type.arguments.joinToString(", ", "<", ">") { typeArg ->
            buildTypeArgumentString(typeArg)
        }

        return "$baseName$typeArgs$nullMark"
    }

    private fun buildTypeArgumentString(typeArg: KSTypeArgument): String {
        val variance = when (typeArg.variance) {
            Variance.COVARIANT -> "out "
            Variance.CONTRAVARIANT -> "in "
            Variance.STAR -> return "*"
            else -> ""
        }

        val type = typeArg.type?.resolve()
        if (type == null) {
            return "${variance}*"
        }

        return "$variance${buildTypeString(type)}"
    }
}

private fun String.capitalize(): String {
    return if (isEmpty()) this else this[0].uppercaseChar() + substring(1)
}
