package love.forte.codegentle.internal.processor.enumset

import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import java.time.ZoneId
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter
import java.time.format.FormatStyle
import java.util.*

/**
 * KSP processor for generating EnumSet implementations for enum classes annotated with @GenEnumSet.
 *
 * @author ForteScarlet
 */
internal class EnumSetProcessor(private val environment: SymbolProcessorEnvironment) : SymbolProcessor {
    private val logger = environment.logger
    private val genEnumSetAnnotationName = "love.forte.codegentle.common.GenEnumSet"
    
    // Collected enum classes to process
    private val collectedEnums = mutableListOf<KSClassDeclaration>()

    override fun process(resolver: Resolver): List<KSAnnotated> {
        // Find all enum classes annotated with @GenEnumSet
        val symbols = resolver.getSymbolsWithAnnotation(genEnumSetAnnotationName)
        
        val enumClasses = symbols
            .filterIsInstance<KSClassDeclaration>()
            .filter { it.classKind == ClassKind.ENUM_CLASS }
            .toList()
        
        logger.info("Found ${enumClasses.size} enum classes with @GenEnumSet annotation")
        
        collectedEnums.addAll(enumClasses)
        
        return emptyList()
    }

    override fun finish() {
        if (collectedEnums.isEmpty()) {
            logger.warn("No enum classes found with @GenEnumSet annotation, skipping code generation")
            return
        }

        for (enumClass in collectedEnums) {
            generateEnumSetImplementation(enumClass)
        }
    }

    private fun generateEnumSetImplementation(enumClass: KSClassDeclaration) {
        val packageName = enumClass.packageName.asString()
        val enumName = enumClass.simpleName.asString()
        
        // Get the enum entries to determine the appropriate EnumSet implementation
        val enumEntries = enumClass.declarations
            .filterIsInstance<KSClassDeclaration>()
            .filter { it.classKind == ClassKind.ENUM_ENTRY }
            .toList()
        
        val enumSize = enumEntries.size
        logger.info("Enum $enumName has $enumSize entries")
        
        // Determine which EnumSet implementation to use based on the number of enum entries
        val baseClass = when {
            enumSize <= 32 -> "I32EnumSet"
            enumSize <= 64 -> "I64EnumSet"
            else -> "BigEnumSet"
        }
        
        // Get the internal flag from the annotation
        val isInternal = enumClass.annotations
            .filter { it.annotationType.resolve().declaration.qualifiedName?.asString() == genEnumSetAnnotationName }
            .firstOrNull()
            ?.arguments
            ?.find { it.name?.asString() == "internal" }
            ?.value as? Boolean ?: false
        
        // Determine visibility modifier
        val visibilityModifier = if (isInternal) "internal" else "public"
        
        // Generate the EnumSet interfaces and implementations
        generateEnumSetCode(enumClass, enumName, packageName, baseClass, visibilityModifier)
    }

    private fun generateEnumSetCode(
        enumClass: KSClassDeclaration,
        enumName: String,
        packageName: String,
        baseClass: String,
        visibilityModifier: String
    ) {
        val dependencies = Dependencies(true, enumClass.containingFile!!)
        
        val outputFile = environment.codeGenerator.createNewFile(
            dependencies,
            packageName,
            "${enumName}Set"
        )
        
        outputFile.bufferedWriter().use { writer ->
            writer.write("// Generated by EnumSetProcessor at ${nowTime()}\n")
            writer.write("@file:Suppress(\"ALL\", \"RedundantVisibilityModifier\", \"unused\")\n\n")
            writer.write("package $packageName\n\n")
            
            // Add imports
            writer.write("import ${enumClass.qualifiedName?.asString()}\n")
            writer.write("import love.forte.codegentle.common.utils.$baseClass\n")
            writer.write("import love.forte.codegentle.common.utils.InternalEnumSetApi\n\n")
            
            // Generate the immutable EnumSet interface
            writer.write("/**\n")
            writer.write(" * A set implementation for the ${enumName} enum.\n")
            writer.write(" * @see $enumName\n")
            writer.write(" */\n")
            writer.write("@OptIn(InternalEnumSetApi::class)\n")
            writer.write("$visibilityModifier interface ${enumName}Set : Set<$enumName> {\n")
            writer.write("    fun mutable(): Mutable${enumName}Set\n\n")
            
            writer.write("    companion object {\n")
            writer.write("        fun empty(): ${enumName}Set = ${enumName}SetImpl()\n")
            
            // Generate the of() factory methods
            writer.write("        fun of(vararg entries: $enumName): ${enumName}Set {\n")
            
            // Generate different implementation based on the base class
            when (baseClass) {
                "I32EnumSet" -> {
                    writer.write("            var bits = 0u\n")
                    writer.write("            for (entry in entries) {\n")
                    writer.write("                bits = bits or (1u shl entry.ordinal)\n")
                    writer.write("            }\n")
                    writer.write("            return ${enumName}SetImpl(bits)\n")
                }
                "I64EnumSet" -> {
                    writer.write("            var bits = 0uL\n")
                    writer.write("            for (entry in entries) {\n")
                    writer.write("                bits = bits or (1uL shl entry.ordinal)\n")
                    writer.write("            }\n")
                    writer.write("            return ${enumName}SetImpl(bits)\n")
                }
                "BigEnumSet" -> {
                    writer.write("            val result = Mutable${enumName}SetImpl()\n")
                    writer.write("            for (entry in entries) {\n")
                    writer.write("                result.add(entry)\n")
                    writer.write("            }\n")
                    writer.write("            return result.immutable()\n")
                }
            }
            
            writer.write("        }\n\n")
            
            // Generate the of(Collection) factory method
            writer.write("        fun of(entries: Collection<$enumName>): ${enumName}Set {\n")
            
            when (baseClass) {
                "I32EnumSet" -> {
                    writer.write("            var bits = 0u\n")
                    writer.write("            for (entry in entries) {\n")
                    writer.write("                bits = bits or (1u shl entry.ordinal)\n")
                    writer.write("            }\n")
                    writer.write("            return ${enumName}SetImpl(bits)\n")
                }
                "I64EnumSet" -> {
                    writer.write("            var bits = 0uL\n")
                    writer.write("            for (entry in entries) {\n")
                    writer.write("                bits = bits or (1uL shl entry.ordinal)\n")
                    writer.write("            }\n")
                    writer.write("            return ${enumName}SetImpl(bits)\n")
                }
                "BigEnumSet" -> {
                    writer.write("            val result = Mutable${enumName}SetImpl()\n")
                    writer.write("            for (entry in entries) {\n")
                    writer.write("                result.add(entry)\n")
                    writer.write("            }\n")
                    writer.write("            return result.immutable()\n")
                }
            }
            
            writer.write("        }\n")
            writer.write("    }\n")
            writer.write("}\n\n")
            
            // Generate the mutable EnumSet interface
            writer.write("/**\n")
            writer.write(" * A mutable set implementation for the ${enumName} enum.\n")
            writer.write(" * @see $enumName\n")
            writer.write(" */\n")
            writer.write("@OptIn(InternalEnumSetApi::class)\n")
            writer.write("$visibilityModifier interface Mutable${enumName}Set : MutableSet<$enumName> {\n")
            writer.write("    fun immutable(): ${enumName}Set\n\n")
            
            writer.write("    companion object {\n")
            writer.write("        fun empty(): Mutable${enumName}Set = Mutable${enumName}SetImpl()\n")
            
            // Generate the of() factory methods
            writer.write("        fun of(vararg entries: $enumName): Mutable${enumName}Set {\n")
            writer.write("            return Mutable${enumName}SetImpl().also {\n")
            writer.write("                if (entries.isNotEmpty()) {\n")
            writer.write("                    it.addAll(entries)\n")
            writer.write("                }\n")
            writer.write("            }\n")
            writer.write("        }\n\n")
            
            // Generate the of(Collection) factory method
            writer.write("        fun of(entries: Collection<$enumName>): Mutable${enumName}Set {\n")
            writer.write("            return Mutable${enumName}SetImpl().also {\n")
            writer.write("                it.addAll(entries)\n")
            writer.write("            }\n")
            writer.write("        }\n")
            writer.write("    }\n")
            writer.write("}\n\n")
            
            // Generate the immutable EnumSet implementation
            writer.write("@OptIn(InternalEnumSetApi::class)\n")
            
            // Generate different implementation based on the base class
            when (baseClass) {
                "I32EnumSet" -> {
                    writer.write("private class ${enumName}SetImpl(bitset: UInt = 0u) : ${enumName}Set, $baseClass<$enumName>() {\n")
                    writer.write("    override var bitset: UInt = bitset\n")
                }
                "I64EnumSet" -> {
                    writer.write("private class ${enumName}SetImpl(bitset: ULong = 0uL) : ${enumName}Set, $baseClass<$enumName>() {\n")
                    writer.write("    override var bitset: ULong = bitset\n")
                }
                "BigEnumSet" -> {
                    writer.write("private class ${enumName}SetImpl(bitset: LongArray = LongArray(0)) : ${enumName}Set, $baseClass<$enumName>() {\n")
                    writer.write("    override var bitset: LongArray = bitset\n")
                }
            }
            
            writer.write("        set(_) {\n")
            writer.write("            throw UnsupportedOperationException(\"Cannot modify the immutable set.\")\n")
            writer.write("        }\n\n")
            
            writer.write("    override val entries: List<$enumName>\n")
            writer.write("        get() = $enumName.entries\n\n")
            
            writer.write("    override fun mutable(): Mutable${enumName}SetImpl =\n")
            
            when (baseClass) {
                "I32EnumSet", "I64EnumSet" -> {
                    writer.write("        Mutable${enumName}SetImpl(bitset)\n")
                }
                "BigEnumSet" -> {
                    writer.write("        Mutable${enumName}SetImpl(bitset.copyOf())\n")
                }
            }
            
            writer.write("}\n\n")
            
            // Generate the mutable EnumSet implementation
            writer.write("@OptIn(InternalEnumSetApi::class)\n")
            
            // Generate different implementation based on the base class
            when (baseClass) {
                "I32EnumSet" -> {
                    writer.write("private class Mutable${enumName}SetImpl(bitset: UInt = 0u) : Mutable${enumName}Set, $baseClass<$enumName>(bitset) {\n")
                }
                "I64EnumSet" -> {
                    writer.write("private class Mutable${enumName}SetImpl(bitset: ULong = 0uL) : Mutable${enumName}Set, $baseClass<$enumName>(bitset) {\n")
                }
                "BigEnumSet" -> {
                    writer.write("private class Mutable${enumName}SetImpl(bitset: LongArray = LongArray(0)) : Mutable${enumName}Set, $baseClass<$enumName>(bitset) {\n")
                }
            }
            
            writer.write("    override val entries: List<$enumName>\n")
            writer.write("        get() = $enumName.entries\n\n")
            
            writer.write("    override fun immutable(): ${enumName}SetImpl =\n")
            
            when (baseClass) {
                "I32EnumSet", "I64EnumSet" -> {
                    writer.write("        ${enumName}SetImpl(bitset)\n")
                }
                "BigEnumSet" -> {
                    writer.write("        ${enumName}SetImpl(bitset.copyOf())\n")
                }
            }
            
            writer.write("}\n")
        }
        
        logger.info("Generated EnumSet implementation for $enumName")
    }

    private fun nowTime(): String {
        return DateTimeFormatter
            .ofLocalizedDateTime(FormatStyle.FULL)
            .withLocale(Locale.ROOT)
            .format(ZonedDateTime.now(ZoneId.of("UTC")))
    }
}
