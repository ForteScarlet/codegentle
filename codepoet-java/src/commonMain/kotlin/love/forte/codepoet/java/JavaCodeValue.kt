@file:JvmName("CodeValues")

package love.forte.codepoet.java

import love.forte.codepoet.common.BuilderDsl
import love.forte.codepoet.common.code.CodeArgumentPart
import love.forte.codepoet.common.code.CodePart
import love.forte.codepoet.common.code.CodeValue
import love.forte.codepoet.common.naming.TypeName
import love.forte.codepoet.common.ref.TypeRef
import love.forte.codepoet.java.internal.JavaJavaCodeValueImpl
import love.forte.codepoet.java.internal.emit0
import kotlin.jvm.JvmName
import kotlin.jvm.JvmStatic

/**
 * ```kotlin
 * CodeValue(format = "%V %V = %V;") {
 *     value(CodePart.type(ClassName("java.lang", "String")))
 *     value(CodePart.literal("value"))
 *     value(CodePart.string("Hello, World"))
 * }
 * ```
 * Will get:
 *
 * ```kotlin
 * java.lang.String value = "Hello, World";
 * ```
 *
 * @author ForteScarlet
 */
public interface JavaCodeValue : CodeValue, JavaCodeEmitter {
    override val parts: List<CodePart>

    override fun emit(codeWriter: JavaCodeWriter) {
        emit(codeWriter, ensureTrailingNewline = false)
    }

    public fun emit(codeWriter: JavaCodeWriter, ensureTrailingNewline: Boolean) {
        emit0(codeWriter, ensureTrailingNewline)
    }

    public companion object {
        internal val EMPTY = JavaJavaCodeValueImpl(emptyList())

        @JvmStatic
        public fun builder(format: String): JavaCodeValueSingleFormatBuilder = JavaCodeValueSingleFormatBuilder(format)

        @JvmStatic
        public fun builder(): JavaCodeValueBuilder = JavaCodeValueBuilder()
    }
}

public operator fun JavaCodeValue.plus(codeValue: JavaCodeValue): JavaCodeValue {
    return JavaCodeValue(parts + codeValue.parts)
}

public typealias CodeValueSingleFormatBuilderDsl = JavaCodeValueSingleFormatBuilder.() -> Unit
public typealias CodeValueBuilderDsl = JavaCodeValueBuilder.() -> Unit

// TODO auto-generated by KSP

public fun JavaCodeValueSingleFormatBuilder.skip(): JavaCodeValueSingleFormatBuilder = value(CodePart.skip())
public fun JavaCodeValueSingleFormatBuilder.literal(value: Any?): JavaCodeValueSingleFormatBuilder =
    value(CodePart.literal(value))

public fun JavaCodeValueSingleFormatBuilder.name(name: String?): JavaCodeValueSingleFormatBuilder =
    value(CodePart.name(name = name))

public fun JavaCodeValueSingleFormatBuilder.name(nameValue: Any): JavaCodeValueSingleFormatBuilder =
    value(CodePart.name(nameValue = nameValue))

public fun JavaCodeValueSingleFormatBuilder.string(value: String?): JavaCodeValueSingleFormatBuilder =
    value(CodePart.string(value))

public fun JavaCodeValueSingleFormatBuilder.type(type: TypeName): JavaCodeValueSingleFormatBuilder =
    // TODO Type -> Ref?
    value(CodePart.type(type))

public fun JavaCodeValueSingleFormatBuilder.type(type: TypeRef): JavaCodeValueSingleFormatBuilder =
    // TODO Type -> Ref?
    value(CodePart.type(type))

// TODO JVM

public fun JavaCodeValueSingleFormatBuilder.indent(levels: Int = 1): JavaCodeValueSingleFormatBuilder =
    value(CodePart.indent(levels))

public fun JavaCodeValueSingleFormatBuilder.unindent(levels: Int = 1): JavaCodeValueSingleFormatBuilder =
    value(CodePart.unindent(levels))

public fun JavaCodeValueSingleFormatBuilder.statementBegin(): JavaCodeValueSingleFormatBuilder =
    value(CodePart.statementBegin())

public fun JavaCodeValueSingleFormatBuilder.statementEnd(): JavaCodeValueSingleFormatBuilder =
    value(CodePart.statementEnd())

public fun JavaCodeValueSingleFormatBuilder.wrappingSpace(): JavaCodeValueSingleFormatBuilder =
    value(CodePart.wrappingSpace())

public fun JavaCodeValueSingleFormatBuilder.zeroWidthSpace(): JavaCodeValueSingleFormatBuilder =
    value(CodePart.zeroWidthSpace())

public fun JavaCodeValueSingleFormatBuilder.otherCodeValue(value: JavaCodeValue): JavaCodeValueSingleFormatBuilder =
    value(CodePart.otherCodeValue(value))

internal fun JavaCodeValue(parts: List<CodePart>): JavaCodeValue {
    return JavaJavaCodeValueImpl(parts)
}

internal fun JavaCodeValue(part: CodePart): JavaCodeValue {
    return JavaJavaCodeValueImpl(listOf(part))
}

public inline fun JavaCodeValue(format: String, block: CodeValueSingleFormatBuilderDsl = {}): JavaCodeValue {
    return JavaCodeValue.builder(format).also(block).build()
}

@JvmName("of")
public fun JavaCodeValue(format: String, argumentPart: CodeArgumentPart): JavaCodeValue {
    return JavaCodeValue(format) {
        value(argumentPart)
    }
}

@JvmName("of")
public fun JavaCodeValue(format: String, vararg argumentParts: CodeArgumentPart): JavaCodeValue {
    return JavaCodeValue(format) {
        values(*argumentParts)
    }
}

@JvmName("of")
public fun JavaCodeValue(format: String, argumentParts: Iterable<CodeArgumentPart>): JavaCodeValue {
    return JavaCodeValue(format) {
        values(argumentParts)
    }
}

public inline fun JavaCodeValue(block: CodeValueBuilderDsl): JavaCodeValue {
    return JavaCodeValue.builder().also(block).build()
}

// Builders

public inline fun JavaCodeValueBuilder.addStatement(
    format: String,
    block: CodeValueSingleFormatBuilderDsl = {}
): JavaCodeValueBuilder = apply {
    addStatement(JavaCodeValue(format, block))
}


public inline fun JavaCodeValueBuilder.beginControlFlow(
    controlFlow: String,
    block: CodeValueSingleFormatBuilderDsl = {}
): JavaCodeValueBuilder =
    apply {
        add("$controlFlow {\n") { block() }
        indent()
    }

public inline fun JavaCodeValueBuilder.nextControlFlow(
    controlFlow: String,
    block: CodeValueSingleFormatBuilderDsl = {}
): JavaCodeValueBuilder =
    apply {
        unindent()
        add("} $controlFlow {\n") { block() }
        indent()
    }

/**
 * @param controlFlow the optional control flow construct and its code, such as
 * `"while(foo == 20)"`. Only used for `"do/while"` control flows.
 */
public inline fun JavaCodeValueBuilder.endControlFlow(
    controlFlow: String,
    block: CodeValueSingleFormatBuilderDsl = {}
): JavaCodeValueBuilder =
    apply {
        unindent()
        add("} $controlFlow;\n") { block() }
    }

/**
 * ```Kotlin
 * builder {
 *  "%V, %V" {
 *    value(...) // for 1st `%V`
 *    value(...) // for 2nd `%V`
 *  }
 *  // Same as
 *  add("%V, %V") {
 *    value(...) // for 1st `%V`
 *    value(...) // for 2nd `%V`
 *  }
 * }
 * ```
 */
public class JavaCodeValueBuilder internal constructor() : BuilderDsl {
    private val parts = mutableListOf<CodePart>()

    @PublishedApi
    internal fun addParts(parts: List<CodePart>): JavaCodeValueBuilder = apply {
        this.parts.addAll(parts)
    }

    public fun add(codeValue: JavaCodeValue): JavaCodeValueBuilder = apply {
        parts.addAll(codeValue.parts)
    }

    public fun add(format: String): JavaCodeValueBuilder = apply {
        parts.add(CodePart.simple(format))
    }

    public fun add(format: String, vararg argumentParts: CodeArgumentPart): JavaCodeValueBuilder = apply {
        addParts(JavaCodeValue.Companion.builder(format).values(*argumentParts).parts())
    }

    public inline fun add(format: String, block: JavaCodeValueSingleFormatBuilder.() -> Unit): JavaCodeValueBuilder =
        apply {
            addParts(JavaCodeValue.Companion.builder(format).also(block).parts())
        }

    public inline operator fun String.invoke(block: JavaCodeValueSingleFormatBuilder.() -> Unit): JavaCodeValueBuilder =
        add(this, block)

    public fun addStatement(format: String, vararg argumentParts: CodeArgumentPart): JavaCodeValueBuilder = apply {
        parts.add(CodePart.statementBegin())
        add(JavaCodeValue(format, *argumentParts))
        add(";\n")
        parts.add(CodePart.statementEnd())
    }

    public fun addStatement(codeValue: JavaCodeValue): JavaCodeValueBuilder = apply {
        parts.add(CodePart.statementBegin())
        add(codeValue)
        add(";\n")
        parts.add(CodePart.statementEnd())
    }

    public fun beginControlFlow(controlFlow: String, vararg argumentParts: CodeArgumentPart): JavaCodeValueBuilder =
        apply {
            add("$controlFlow {\n", *argumentParts)
            indent()
        }

    public fun nextControlFlow(controlFlow: String, vararg argumentParts: CodeArgumentPart): JavaCodeValueBuilder =
        apply {
            unindent()
            add("} $controlFlow {\n", *argumentParts)
            indent()
        }

    public fun endControlFlow(): JavaCodeValueBuilder = apply {
        unindent()
        add("}\n")
    }

    /**
     * @param controlFlow the optional control flow construct and its code, such as
     * `"while(foo == 20)"`. Only used for `"do/while"` control flows.
     */
    public fun endControlFlow(controlFlow: String, vararg argumentParts: CodeArgumentPart): JavaCodeValueBuilder =
        apply {
            unindent()
            add("} $controlFlow;\n", *argumentParts)
        }

    public fun indent(): JavaCodeValueBuilder = apply {
        parts.add(CodePart.indent())
    }

    public fun unindent(): JavaCodeValueBuilder = apply {
        parts.add(CodePart.unindent())
    }

    public fun clear(): JavaCodeValueBuilder = apply {
        parts.clear()
    }

    public fun build(): JavaCodeValue = JavaJavaCodeValueImpl(parts)
}

/**
 * The Builder for [JavaCodeValue] with single [format] target.
 *
 * ```Kotlin
 * builder("%V %V = %V;") {
 *   value(...) // For 1st `%V`
 *   value(...) // For 2nd `%V`
 *   value(...) // For 3rd `%V`
 * }.build()
 * ```
 *
 */
public class JavaCodeValueSingleFormatBuilder internal constructor(public val format: String) : BuilderDsl {
    private val arguments = mutableListOf<CodeArgumentPart>()

    /**
     * Add a [CodeArgumentPart] for next argument placeholder.
     */
    public fun value(argument: CodeArgumentPart): JavaCodeValueSingleFormatBuilder = apply {
        arguments.add(argument)
    }

    /**
     * Add some [CodeArgumentPart]s for next argument placeholder.
     */
    public fun values(vararg arguments: CodeArgumentPart): JavaCodeValueSingleFormatBuilder = apply {
        this.arguments.addAll(arguments)
    }

    /**
     * Add some [CodeArgumentPart]s for next argument placeholder.
     */
    public fun values(arguments: Iterable<CodeArgumentPart>): JavaCodeValueSingleFormatBuilder = apply {
        this.arguments.addAll(arguments)
    }

    @PublishedApi
    internal fun parts(): List<CodePart> {
        if (arguments.isEmpty()) {
            return listOf(CodePart.simple(format))
        }

        val argumentsStack = ArrayDeque(arguments)
        val parts = mutableListOf<CodePart>()

        var last = false

        var i = 0
        for (simplePart in format.splitToSequence(CodePart.PLACEHOLDER)) {
            if (simplePart.isNotEmpty()) {
                parts.add(CodePart.simple(simplePart))
            }
            // remove stack first
            val nextArg = argumentsStack.removeFirstOrNull()

            if (nextArg == null) {
                check(!last) { "Miss argument in index $i" }
                last = true
            } else {
                parts.add(nextArg)
            }

            i++
        }

        check(argumentsStack.isEmpty()) { "${argumentsStack.size} redundant argument(s): $argumentsStack" }

        return parts
    }

    public fun build(): JavaCodeValue = JavaJavaCodeValueImpl(parts())
}
